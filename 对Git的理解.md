# 对Git的理解
Git是程序员都离不开的工具。最近又深入学习了一下Git的知识。
## 为什么需要Git？
程序代码是一种容错率非常低的文本文件，为什么这么说？

比如打开一个PPT，拖动上面的一个图片移动了一点点，文件发生了变化，但是和之前几乎看不出什么差别，这样的变化几乎不会产生任何影响。

而代码则不同，哪怕一个字符的改动，都可能导致整个程序无法运行；在Python中甚至一个空格的改变也会如此。

所以，当我们写出一个能够符合预期运行的代码时，就迫切地需要把它保存下来，且永远都无法改动，也不会被删除，任何时候都能找回这个版本的代码。

**这就是第一个需求：保存历史版本。**

但是仅仅本地保存代码版本还不够，我们需要协作开发，就需要能够获取到其他人的代码版本。利用网络，将本地的代码版本分享给其他人并不困难，例如用一个网盘，每个人将自己的代码版本都传上去。但是当协作的人非常多时，这样的做法存在很大的问题。

例如最初的代码版本1，开发者A对一个功能其进行了修改，保存了一个新版本2并上传；开发者B对其另一个功能进行了修改，保存了一个新版本3并上传，如何能将两处改动合并呢？人数越多，这样的情况就越难以处理。

**这就有了第二个需求：对每个版本的变化量进行合并。**

## Git是怎么做的
### .git目录
在git仓库根目录中存在一个名为 `.git`的隐藏文件夹，所有的历史版本文件其实都是存在这里的。

同一个文件很可能出现在在多个历史版本中，如何避免命名冲突呢？也许你会想到：为每个版本建立一个文件夹。但Git采用了更好的办法。

### 内容寻址文件系统
Git底层实际上是一个内容寻址文件系统。什么是内容寻址文件系统？简单说就是：文件的地址（路径）取决于文件的内容。

一般我们在电脑中选定一个文件夹，在其中创建一个文件，并命名，这个文件的地址就定了，与文件的内容并没有关系。文件内容可以任意更改，而地址不会改变。

#### Git是如何保存你的文件的？
Git会将你的文件进行Hash运算，得到一个字符串，并以这个字符串作为文件路径，把这个文件保存在这个路径下。在Git中，实际上是将字符串的前两位作为文件夹，其余作为文件名来保存。这样保存的文件叫做**数据对象**。

Hash运算的特点是，文件内容只要有一点微小的不同，得到的Hash码就完全不一样。因此，Hash码也可以用来校验文件内容，确认文件没有被更改过。

在内容寻址文件系统中，只要知道文件的Hash码，就可以找到文件，必要时还可以校验文件是否被篡改过（正常情况下不应该有任何改动）。

#### 举个例子
有一个文件，名为`file1.txt`，我们对它进行了两次改动，保存了两个版本。

在普通的文件系统中，我们可以将这两个版本的文件保存为 `/version1/file1.txt` 和`/version2/file1.txt`。

而在内容寻址文件系统中，例如这两个版本的文件计算得到的Hash码分别为 `a1b23` 和 `c5d67`，那么他们分别可以保存为`/a1/b23`和`/c5/d67`

#### 如何查找历史？
你也许要问了，如果我想要找到某一个版本的file1文件，对于普通的文件系统，只需要知道版本名称（如version1）和文件名（file1.txt）就可以知道这个版本的文件的存储路径（/version1/file1.txt），就能找到它，这两个名称都很好记；而内容寻址文件系统则需要知道Hash码，这是个无意义的字符串，怎么可能记得住呢？

其实，解决办法也很简单，只要增加一个文件，记录文件名、版本号和文件的Hash码不就可以了？这就是**树对象**和**提交对象**做的事情，它们分别保存文件的目录结构和提交的版本信息。于是，我们只要找到一个版本的提交对象，就可以顺藤摸瓜找到这个版本的所有目录结构和文件内容。

![提交对象、树对象与数据对象 (来源：git-scm.com)](https://git-scm.com/book/en/v2/images/commit-and-tree.png)

那么最后，问题转化为：如何查找一个提交对象？我们当然可以根据时间、提交信息、作者等信息查找，Git中也提供了`引用`。引用可以指向一个提交对象，并可以由用户命名。这样，我们终于不用记不友好的Hash码了，只要记住引用的名字即可。

#### 小结一下
Git是这样记录历史版本的文件的：每一个文件都保存在`.git/objects/`目录下，以Hash值作为路径的文件中，形成一个数据对象；一个版本的所有文件的文件名和目录结构，以及其对应的Hash码记录在树对象中；这个版本的提交时间、作者、版本说明等信息，以及最顶层树对象的树对象的Hash码，记录在提交对象中；引用可以指向一个提交对象，便于查找历史提交。

至此，Git完成了上面说的第一个需求：保存历史版本。

### 提交链与分支
上面讲了Git中如何存储一个版本的文件。但是当版本非常多时，可能会非常混乱，尤其是当出现分叉时，即：两个人分别基于同一个版本的代码做出了不同的修改，并各自提交了一个版本。

#### 提交链
对于上面这种例子，多数情况下，我们会希望将两个人做出的变动合并，形成一个新版本。要达到这种效果，对于每次提交，Git必须知道这次提交是基于之前的哪一次提交做的改动，也就是必须有父提交（当然第一次提交除外）。于是，提交与提交之间连接形成一条链。
![(来源：git-scm.com)](https://git-scm.com/book/en/v2/images/commits-and-parents.png)

但其实这不只是一条链。当多个提交拥有同一个父提交时，这也就产生了分叉，现在看上去，提交历史形成了树结构。但还有一种特殊的提交，可以将两个提交合并，也就是有两个父提交。所以严格来说，提交历史既不是一条链，也不是一棵树。它有直线，有分叉，也有合并。

形成提交链之后，当我们有一个提交，就可以找到它的父提交。父提交的意思是：这次提交的版本是在哪个版本的基础上修改得到的。以此类推，就可以找到这次提交之前基于的所有版本的提交记录。因此，只要有一个指向最新提交的引用，就可以找到这次提交之前的整个提交链。这样一个引用，也可以叫做`分支`。

#### 分支
提交历史分叉其实不一定是意外，也可能是有意而为。例如：一个项目现在有两个需求，分别由两个小组进行开发。为了避免两组提交的代码相互影响，可以每组一个分叉进行开发，直到完成需求后再进行合并。这就要用到Git中的分支。

初始时，Git只有一个主分支，即`master`分支，有一个名为master的引用指向一个提交，这个提交即为master分支的最新提交。当我们在master分支上提交一个新版本后，master引用会自动指向最新的提交。

对于任何一个提交，我们都可以创建一个引用指向它，也就是创建一个分支。在哪个分支上产生新提交，就会使哪个引用更新，指向最新的提交。

当我们在不同的分支上分别进行提交时，分叉便形成了。每一次引用的更新，都是提交链的延伸；而不同的引用使得提交链朝着不同方向分叉，渐行渐远。当然，可以通过合并操作将两个分支合并。

#### HEAD指针
刚才说在不同的分支上提交会使不同的分支向前延伸，那么Git是如何知道我们当前处于哪一个分支的呢？这就用到一个符号引用——HEAD。

符号引用的意思是，它指向的也是一个引用，HEAD指针往往指向一个分支。当我们编写代码时，HEAD的含义就是：当前修改的代码是基于哪一个提交版本进行的。因此，当我们提交一个新的版本，它的父提交就是此时HEAD指向分支的那个提交。

![(来源：git-scm.com)](https://git-scm.com/book/en/v2/images/advance-master.png)

例如：HEAD指向master分支，而master分支指向`c5d67`这次提交。此时提交一个新的版本，新版本的父提交即为`c5d67`。新版本提交后，master分支会指向最新的提交，而HEAD仍然指向master，也就是指向了最新的提交。

#### 合并与冲突
由于所有的提交都形成了一条链，当我们想要合并两个分支时，Git可以先找到两个分支的第一个共同祖先，然后就可以比较两个分支在共同祖先的基础上进行了哪些修改。当两个分支各自修改了不同的文件，那么Git可以自动合并两个分支的修改。

但是，如果两个分支都对同一个文件同一行进行了修改，而且修改并不相同，那么Git就不知道应该如何合并，就产生了冲突。Git会把产生冲突的地方标出来，需要手动解决冲突后进行合并。

这样，第二条需求，合并更改也就完成了。

## 总结
以上就是Git的一部分基本原理。总体看下来，Git确实是一个十分优雅的设计。想进一步了解，可以进入Git的官网学习高级教程。中文版连接：`https://git-scm.com/book/zh/v2`。
 